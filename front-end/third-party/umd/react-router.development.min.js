!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("history"),require("react")):"function"==typeof define&&define.amd?define(["exports","history","react"],t):t((e=e||self).ReactRouter={},e.HistoryLibrary,e.React)}(this,function(e,d,f){"use strict";const v=f.createContext(null);v.displayName="Navigation";const g=f.createContext(null);g.displayName="Location";const p=f.createContext({outlet:null,matches:[]});function y(e,t){if(!e)throw new Error(t)}function R(e,t){if(!e){"undefined"!=typeof console&&console.warn(t);try{throw new Error(t)}catch(e){}}}p.displayName="Route";const m={};function b(e,t,n){void 0===n&&(n="/");var a=C(("string"==typeof t?d.parsePath(t):t).pathname||"/",n);if(null==a)return null;var r=function o(e,i,s,u){void 0===i&&(i=[]);void 0===s&&(s=[]);void 0===u&&(u="");e.forEach((e,t)=>{let n={relativePath:e.path||"",caseSensitive:!0===e.caseSensitive,childrenIndex:t,route:e};n.relativePath.startsWith("/")&&(n.relativePath.startsWith(u)||y(!1,'Absolute route path "'+n.relativePath+'" nested under path "'+u+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),n.relativePath=n.relativePath.slice(u.length));let a=E([u,n.relativePath]),r=s.concat(n);e.children&&0<e.children.length&&(!0===e.index&&y(!1,'Index routes must not have child routes. Please remove all child routes from route path "'+a+'".'),o(e.children,i,r,a)),null==e.path&&!e.index||i.push({path:a,score:c(a,e.index),routesMeta:r})});return i}(e);r.sort((e,t)=>e.score!==t.score?t.score-e.score:function(e,n){var t=e.length===n.length&&e.slice(0,-1).every((e,t)=>e===n[t]);return t?e[e.length-1]-n[n.length-1]:0}(e.routesMeta.map(e=>e.childrenIndex),t.routesMeta.map(e=>e.childrenIndex)));let o=null;for(let e=0;null==o&&e<r.length;++e)o=function(e,t){let n=e["routesMeta"],a={},r="/",o=[];for(let e=0;e<n.length;++e){var i=n[e],s=e===n.length-1,u="/"===r?t:t.slice(r.length)||"/",u=x({path:i.relativePath,caseSensitive:i.caseSensitive,end:s},u);if(!u)return null;Object.assign(a,u.params);i=i.route;o.push({params:a,pathname:E([r,u.pathname]),pathnameBase:N(E([r,u.pathnameBase])),route:i}),"/"!==u.pathnameBase&&(r=E([r,u.pathnameBase]))}return o}(r[e],a);return o}const r=/^:\w+$/,o=3,i=2,s=1,u=10,l=-2,h=e=>"*"===e;function c(e,t){let n=e.split("/"),a=n.length;return n.some(h)&&(a+=l),t&&(a+=i),n.filter(e=>!h(e)).reduce((e,t)=>e+(r.test(t)?o:""===t?s:u),a)}function x(e,t){let[n,a]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);R("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(e,t)=>(a.push(t),"([^\\/]+)"));e.endsWith("*")?(a.push("*"),r+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):r+=n?"\\/*$":"(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";t=new RegExp(r,t?void 0:"i");return[t,a]}((e="string"==typeof e?{path:e,caseSensitive:!1,end:!0}:e).path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let o=r[0],i=o.replace(/(.)\/+$/,"$1"),s=r.slice(1);return{params:a.reduce((e,t,n)=>{var a;return"*"===t&&(a=s[n]||"",i=o.slice(0,o.length-a.length).replace(/(.)\/+$/,"$1")),e[t]=function(t,n){try{return decodeURIComponent(t)}catch(e){return R(!1,'The value for the URL param "'+n+'" will not be decoded because the string "'+t+'" is a malformed URL segment. This is probably due to a bad percent encoding ('+e+")."),t}}(s[n]||"",t),e},{}),pathname:o,pathnameBase:i,pattern:e}}function P(e,t){void 0===t&&(t="/");let{pathname:n,search:a="",hash:r=""}="string"==typeof e?d.parsePath(e):e;return{pathname:n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/"),a=e.split("/");return a.forEach(e=>{".."===e?1<n.length&&n.pop():"."!==e&&n.push(e)}),1<n.length?n.join("/"):"/"}(n,t):t,search:(t=a)&&"?"!==t?t.startsWith("?")?t:"?"+t:"",hash:(t=r)&&"#"!==t?t.startsWith("#")?t:"#"+t:""}}function w(e,n,t){let a="string"==typeof e?d.parsePath(e):e,r=""===e||""===a.pathname?"/":a.pathname,o;if(null==r)o=t;else{let t=n.length-1;if(r.startsWith("..")){let e=r.split("/");for(;".."===e[0];)e.shift(),--t;a.pathname=e.join("/")}o=0<=t?n[t]:"/"}let i=P(a,o);return r&&"/"!==r&&r.endsWith("/")&&!i.pathname.endsWith("/")&&(i.pathname+="/"),i}function C(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;var n=e.charAt(t.length);return n&&"/"!==n?null:e.slice(t.length)||"/"}const E=e=>e.join("/").replace(/\/\/+/g,"/"),N=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/");function S(){return null!=f.useContext(g)}function $(){return S()||y(!1,"useLocation() may be used only in the context of a <Router> component."),f.useContext(g).location}function M(){S()||y(!1,"useNavigate() may be used only in the context of a <Router> component.");let{basename:a,navigator:r}=f.useContext(v),e=f.useContext(p)["matches"],o=$()["pathname"],i=JSON.stringify(e.map(e=>e.pathnameBase)),s=f.useRef(!1);return f.useEffect(()=>{s.current=!0}),f.useCallback(function(t,n){if(void 0===n&&(n={}),R(s.current,"You should call navigate() in a React.useEffect(), not when your component is first rendered."),s.current)if("number"!=typeof t){let e=w(t,JSON.parse(i),o);"/"!==a&&(e.pathname=E([a,e.pathname])),(n.replace?r.replace:r.push)(e,n.state)}else r.go(t)},[a,r,i,o])}const n=f.createContext(null);function t(e){var t=f.useContext(p).outlet;return t&&f.createElement(n.Provider,{value:e},t)}function W(e){let t=f.useContext(p)["matches"],n=$()["pathname"],a=JSON.stringify(t.map(e=>e.pathnameBase));return f.useMemo(()=>w(e,JSON.parse(a),n),[e,a,n])}function a(e,t){S()||y(!1,"useRoutes() may be used only in the context of a <Router> component.");var n=f.useContext(p)["matches"],a=n[n.length-1];let r=a?a.params:{};var o=a?a.pathname:"/";let i=a?a.pathnameBase:"/";var s=a&&a.route;{let e=s&&s.path||"";u=o,a=!s||e.endsWith("*"),o='You rendered descendant <Routes> (or called `useRoutes()`) at "'+o+'" (under <Route path="'+e+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="'+e+'"> to <Route path="'+("/"===e?"*":e+"/*")+'">.',a||m[u]||R(!(m[u]=!0),o)}var u=$();let l;l=t?(o="string"==typeof t?d.parsePath(t):t,"/"===i||null!=(t=o.pathname)&&t.startsWith(i)||y(!1,'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'+i+'" but pathname "'+o.pathname+'" was given in the `location` prop.'),o):u;let h=l.pathname||"/",c=b(e,{pathname:"/"===i?h:h.slice(i.length)||"/"});return R(s||null!=c,'No routes matched location "'+l.pathname+l.search+l.hash+'" '),R(null==c||void 0!==c[c.length-1].route.element,'Matched leaf route at location "'+l.pathname+l.search+l.hash+'" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'),O(c&&c.map(e=>Object.assign({},e,{params:Object.assign({},r,e.params),pathname:E([i,e.pathname]),pathnameBase:"/"===e.pathnameBase?i:E([i,e.pathnameBase])})),n)}function O(a,r){return void 0===r&&(r=[]),null==a?null:a.reduceRight((e,t,n)=>f.createElement(p.Provider,{children:void 0!==t.route.element?t.route.element:e,value:{outlet:e,matches:r.concat(a.slice(0,n+1))}}),null)}function T(e){y(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function L(e){let{basename:t="/",children:n=null,location:a,navigationType:r=d.Action.Pop,navigator:o,static:i=!1}=e;S()&&y(!1,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let s=N(t);var u=f.useMemo(()=>({basename:s,navigator:o,static:i}),[s,o,i]);"string"==typeof a&&(a=d.parsePath(a));let{pathname:l="/",search:h="",hash:c="",state:p=null,key:m="default"}=a;e=f.useMemo(()=>{var e=C(l,s);return null==e?null:{pathname:e,search:h,hash:c,state:p,key:m}},[s,l,h,c,p,m]);return R(null!=e,'<Router basename="'+s+'"> is not able to match the URL "'+l+h+c+"\" because it does not start with the basename, so the <Router> won't render anything."),null==e?null:f.createElement(v.Provider,{value:u},f.createElement(g.Provider,{children:n,value:{location:e,navigationType:r}}))}function j(e){let n=[];return f.Children.forEach(e,t=>{if(f.isValidElement(t))if(t.type!==f.Fragment){t.type!==T&&y(!1,"["+("string"==typeof t.type?t.type:t.type.name)+"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>");let e={caseSensitive:t.props.caseSensitive,element:t.props.element,index:t.props.index,path:t.props.path};t.props.children&&(e.children=j(t.props.children)),n.push(e)}else n.push.apply(n,j(t.props.children))}),n}Object.defineProperty(e,"NavigationType",{enumerable:!0,get:function(){return d.Action}}),Object.defineProperty(e,"createPath",{enumerable:!0,get:function(){return d.createPath}}),Object.defineProperty(e,"parsePath",{enumerable:!0,get:function(){return d.parsePath}}),e.MemoryRouter=function(e){var{basename:t,children:n,initialEntries:a,initialIndex:e}=e;let r=f.useRef();null==r.current&&(r.current=d.createMemoryHistory({initialEntries:a,initialIndex:e}));let o=r.current,[i,s]=f.useState({action:o.action,location:o.location});return f.useLayoutEffect(()=>o.listen(s),[o]),f.createElement(L,{basename:t,children:n,location:i.location,navigationType:i.action,navigator:o})},e.Navigate=function(e){let{to:t,replace:n,state:a}=e;S()||y(!1,"<Navigate> may be used only in the context of a <Router> component."),R(!f.useContext(v).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let r=M();return f.useEffect(()=>{r(t,{replace:n,state:a})}),null},e.Outlet=function(e){return t(e.context)},e.Route=T,e.Router=L,e.Routes=function(e){var{children:t,location:e}=e;return a(j(t),e)},e.UNSAFE_LocationContext=g,e.UNSAFE_NavigationContext=v,e.UNSAFE_RouteContext=p,e.createRoutesFromChildren=j,e.generatePath=function(e,n){return void 0===n&&(n={}),e.replace(/:(\w+)/g,(e,t)=>(null==n[t]&&y(!1,'Missing ":'+t+'" param'),n[t])).replace(/\/*\*$/,e=>null==n["*"]?"":n["*"].replace(/^\/*/,"/"))},e.matchPath=x,e.matchRoutes=b,e.renderMatches=function(e){return O(e)},e.resolvePath=P,e.useHref=function(t){S()||y(!1,"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:e}=f.useContext(v);var{hash:a,pathname:r,search:o}=W(t);let i=r;if("/"!==n){let e=""===(t=t)||""===t.pathname?"/":("string"==typeof t?d.parsePath(t):t).pathname;t=null!=e&&e.endsWith("/");i="/"===r?n+(t?"/":""):E([n,r])}return e.createHref({pathname:i,search:o,hash:a})},e.useInRouterContext=S,e.useLocation=$,e.useMatch=function(e){S()||y(!1,"useMatch() may be used only in the context of a <Router> component.");let t=$()["pathname"];return f.useMemo(()=>x(e,t),[t,e])},e.useNavigate=M,e.useNavigationType=function(){return f.useContext(g).navigationType},e.useOutlet=t,e.useOutletContext=function(){return f.useContext(n)},e.useParams=function(){var e=f.useContext(p)["matches"];return(e=e[e.length-1])?e.params:{}},e.useResolvedPath=W,e.useRoutes=a,Object.defineProperty(e,"__esModule",{value:!0})});